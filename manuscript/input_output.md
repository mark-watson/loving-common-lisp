# Input and Output {#input_output}

We will see that the input and output of Lisp data is handled using streams. Streams are powerful abstractions that support common libraries of functions for writing to the terminal, files, sockets, and to strings.

In all cases, if an input or output function is called without specifying a stream, the default for input stream is **\*standard-input\*** and the default for output stream is **\*standard-output\***. These default streams are connected to the Lisp listener that we discussed in Chapter 2. In the later chapter [Knowledge Graph Navigator](#kgn) that supports a user interface, we will again use output streams bound to different scrolling output areas of the application window to write color-hilighted text. The stream formalism is general purpose, covering many common I/O use cases.

## The Lisp read and read-line Functions

The function **read** is used to read one Lisp expression. Function read stops reading after reading one expression and ignores new line characters. We will look at a simple example of reading a file **test.dat** using the example Lisp program in the file **read-test-1.lisp**. Both of these files can be found in the directory **src/code_snippets_for_book** that came bundled with this web book. Start your Lisp program in the src directory. The contents of the file **test.dat** is:

~~~~~~~~
1 2 3
4 "the cat bit the rat"
        read with-open-file
~~~~~~~~

In the function **read-test-1**, we use the macro with-open-file to read from a file. To write to a file (which we will do later), we can use the keyword arguments **:direction :output**. The first argument to the macro **with-open-file** is a symbol that is bound to a newly created input stream (or an output stream if we are writing a file); this symbol can then be used in calling any function that expects a stream argument.

Notice that we call the function **read** with three arguments: an input stream, a flag to indicate if an error should be thrown if there is an I/O error (e.g., reaching the end of a file), and the third argument is the value that function **read** should return if the end of the file (or stream) is reached. When calling **read** with these three arguments, either the next expression from the file **test.dat** will be returned, or the value nil will be returned when the end of the file is reached. If we do reach the end of the file, the local variable **x** will be assigned the value nil and the function return will break out of the **dotimes** loop. One big advantage of using the macro **with-open-file** over using the open function (which we will not cover) is that the file stream is automatically closed when leaving the code generated by the **with-open-file macro**. The contents of file **read-test-1.lisp** is:

{lang="lisp",linenos=off}
~~~~~~~~
(defun read-test-1 ()
  "read a maximum of 1000 expressions from the file 'test.dat'"
  (with-open-file
   (input-stream "test.dat" :direction :input)
   (dotimes (i 1000)
     (let ((x (read input-stream nil nil)))
       (if (null x) (return)) ;; break out of the 'dotimes' loop
       (format t "next expression in file: ~S~%" x)))))
~~~~~~~~

Here is the output that you will see if you load the file read-test-1.lisp and execute the expression (read-test-1):

~~~~~~~~
* (load "read-test-1.lisp")
;; Loading file read-test-1.lisp ...
;; Loading of file read-test-1.lisp is finished.
T
* (read-test-1)
next expression in file: 1
next expression in file: 2
next expression in file: 3
next expression in file: 4
next expression in file: "the cat bit the rat"
NIL
~~~~~~~~

Note: the string "the cat bit the rat" prints as a string (with quotes) because we used a ~S  instead of a ~A  in the format string in the call to function **format**.

In this last example, we passed the file name as a string to the macro **with-open-file**. This is not generally portable across all operating systems. Instead, we could have created a pathname object and passed that instead. The **pathname** function can take eight different keyword arguments, but we will use only the two most common in the example in the file **read-test-2.lisp** in the **src** directory. The following listing shows just the differences between this example and the last:

{lang="lisp",linenos=off}
~~~~~~~~
  (let ((a-path-name
          (make-pathname :directory "testdata"
                         :name "test.dat")))
    (with-open-file
     (input-stream a-path-name :direction :input)
~~~~~~~~

Here, we are specifying that we want to use the file **test.dat** in the subdirectory **testdata**. Note: I almost never use pathnames. Instead, I specify files using a string and the character / as a directory delimiter. I find this to be portable for the Macintosh, Windows, and Linux operating systems using all Common Lisp implementations.

The file **readline-test.lisp** is identical to the file **read-test-1.lisp** except that we call function **readline** instead of the function **read** and we change the output format message to indicate that an entire line of text has been read

{lang="lisp",linenos=off}
~~~~~~~~
(defun readline-test ()
  "read a maximum of 1000 expressions from the file 'test.dat'"
  (with-open-file
   (input-stream "test.dat" :direction :input)
   (dotimes (i 1000)
     (let ((x (read-line input-stream nil nil)))
       (if (null x) (return)) ;; break out of the 'dotimes' loop
       (format t "next line in file: ~S~%" x)))))
~~~~~~~~

When we execute the expression (readline-test), notice that the string contained in the second line of the input file has the quote characters escaped:

~~~~~~~~
* (load "readline-test.lisp")
;; Loading file readline-test.lisp ...
;; Loading of file readline-test.lisp is finished.
T
* (readline-test)
next line in file: "1 2 3"
next line in file: "4 \"the cat bit the rat\""
NIL
*
~~~~~~~~

We can also create an input stream from the contents of a string. The file **read-from-string-test.lisp** is very similar to the example file **read-test-1.lisp** except that we use the macro **with-input-from-string** (notice how I escaped the quote characters used inside the test string):

{lang="lisp",linenos=off}
~~~~~~~~
(defun read-from-string-test ()
  "read a maximum of 1000 expressions from a string"
  (let ((str "1 2 \"My parrot is named Brady.\" (11 22)"))
    (with-input-from-string
     (input-stream str)
     (dotimes (i 1000)
       (let ((x (read input-stream nil nil)))
         (if (null x) (return)) ;; break out of the 'dotimes' loop
         (format t "next expression in string: ~S~%" x))))))
~~~~~~~~

We see the following output when we load the file **read-from-string-test.lisp**:

~~~~~~~~
* (load "read-from-string-test.lisp")
;; Loading file read-from-string-test.lisp ...
;; Loading of file read-from-string-test.lisp is finished.
T
* (read-from-string-test)
next expression in string: 1
next expression in string: 2
next expression in string: "My parrot is named Brady."
next expression in string: (11 22)
NIL
*
~~~~~~~~

We have seen how the stream abstraction is useful for allowing the same operations on a variety of stream data. In the next section, we will see that this generality also applies to the Lisp printing functions.


## Lisp Printing Functions

All of the printing functions that we will look at in this section take an optional last argument that is an output stream. The exception is the format function that can take a stream value as its first argument (or **t** to indicate **\*standard-output\***, or a **nil** value to indicate that format should return a string value).

Here is an example of specifying the optional stream argument: 

~~~~~~~~
* (print "testing")

"testing" 
"testing"
* (print "testing" *standard-output*)

"testing" 
"testing"
*
~~~~~~~~

The function **print** prints Lisp objects so that they can be read back using function read. The corresponding function **princ** is used to print for "human consumption". For example:

~~~~~~~~
* (print "testing")

"testing" 
"testing"
* (princ "testing")
testing
"testing"
* 
~~~~~~~~

Both **print** and **princ** return their first argument as their return value, which you see in the previous output. Notice that **princ** also does not print a new line character, so **princ** is often used with **terpri** (which also takes an optional stream argument).

We have also seen many examples in this book of using the **format** function. Here is a different use of format, building a string by specifying the value nil for the first argument:

~~~~~~~~
* (let ((l1 '(1 2))
           (x 3.14159))
       (format nil "~A~A" l1 x))
"(1 2)3.14159"
* 
~~~~~~~~

We have not yet seen an example of writing to a file. Here, we will use the **with-open-file** macro with options to write a file and to delete any existing file with the same name:

{lang="lisp",linenos=off}
~~~~~~~~
(with-open-file (out-stream "test1.dat"
                   :direction :output
                   :if-exists :supersede)
       (print "the cat ran down the road" out-stream)
       (format out-stream "1 + 2 is: ~A~%" (+ 1 2))
       (princ "Stoking!!" out-stream)
       (terpri out-stream))
~~~~~~~~

Here is the result of evaluating this expression (i.e., the contents of the newly created file **test1.dat** in the **src** directory):

~~~~~~~~
% cat test1.dat 

"the cat ran down the road" 1 + 2 is: 3
Stoking!!
~~~~~~~~

Notice that **print** generates a new line character before printing its argument.
